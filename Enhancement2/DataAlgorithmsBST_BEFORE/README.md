# CS300-DSA-Journal


    What was the problem you were solving in the projects for this course?
An analysis of three different data structures - vectors, hash tables, and binary search trees - were analyzed on their runtime efficiency. Binary search trees were decided on for the final project, in which course data would be loaded into the program and stored in a tree. The user can output the entire courselist in alphanumeric order, or they can search a specific course to learn about the courses prerequisites.
    
    How did you approach the problem? Consider why data structures are important to understand.
My approach of the problem considered the speed in which binary search trees can output sorted data through recursive calls. The tree sorts while building more efficiently than having to run a separate sorting function. For a program with this goal in mind, understanding which data structure would be optimal is important. Performance, speed, and memory usage are important factors to consider alongside the goal of the project.
    
    How did you overcome any roadblocks you encountered while going through the activities or project?
I overcomed roadblocks by detailing the block I was experiencing. Outlining the problem, what should happen and what was not happening helped with troubleshooting errors. This allowed me to have a better starting point for research into problems and errors, so that when I returned to writing the program, I could have a fresh perspective with new concepts in mind.
    
    How has your work on this project expanded your approach to designing software and developing programs?
This project has helped me understand the workflow when it comes to development. First, a plan needs to be created. Thought and analysis will help determine how to make a program run more efficiently. Pseudocode doesn't need to be perfect, it needs to only be thorough enough to give a general idea of the flow of a program by outlining key variables and functions. Coding itself will then be a much smoother process with minimal errors, with all of the proper planning in place.
    
    How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Organizing code for future development is important. Comments should clearly define each function in a way that accurately depicts what the function will do, and inline comments should detail the logic behind each snippet of code. This prevents wasting time with trying to figure out how a program is run; it is already detailed in plain English.
